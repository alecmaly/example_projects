["struct AuthorizedCallerArgs {\n    address[] addedCallers;\n    address[] removedCallers;\n  }", "struct Permission {\n    address forwarder; // \u2500\u2500\u2500\u2500\u2500\u2500\u256e The address of the forwarder (20 bytes)\n    bytes10 workflowName; //    \u2502 The name of the workflow in bytes10\n    bytes2 reportName; // \u2500\u2500\u2500\u2500\u2500\u2500\u256f The name of the report in bytes2\n    address workflowOwner; // \u2500\u2500\u256e The address of the workflow owner (20 bytes)\n    bool isAllowed; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the report is allowed or not (1 byte)\n  }\n\n  /// @notice Event emitted when report permissions ar", "struct TokenPriceFeedConfig {\n    address dataFeedAddress; // \u2500\u256e Price feed contract. Can be address(0) to indicate no feed is configured.\n    uint8 tokenDecimals; //      \u2502 Decimals of the token, used for both keystone and price feed decimal multiplications.\n    bool isEnabled; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the token is configured to receive keystone and/or price feed updates.\n  }\n\n  /// @dev Token price dat", "{\n    address sourceToken; // Source token to update feed for.\n    TokenPriceFeedConfig feedConfig; // Feed config update data.\n  }\n\n  /// @dev Struct that con", "nt96 maxFeeJuelsPerMsg; // \u2500\u256e Maximum fee that can be charged for a message.\n    address linkToken; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f LINK token address.\n    // The amount of time a token price can be stale before it is considered invalid. Gas price staleness is configured\n    // per dest chain.\n    uint32 tokenPriceStalenessThreshold;\n  }\n\n  /// @dev The struct representing the received ", " //       Token address.\n    uint224 price; // \u2500\u2500\u2500\u2500\u256e Price of the token in USD with 18 decimals.\n    uint32 timestamp; // \u2500\u256f Timestamp of the price update.\n  }\n\n  /// @dev Struct to hold the fee & validation configs for a d", "\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e Whether this destination chain is enabled.\n    uint16 maxNumberOfTokensPerMsg; //           \u2502 Maximum number of distinct ERC20 tokens transferred per message.\n    uint32 maxDataBytes; //                      \u2502 Maximum data payload size in bytes.\n    uint32 maxPerMsgGasLimit; //                 \u2502 Maximum gas limit for messages targeting EVMs.\n    uint32 destGasOverhead; //                   \u2502 Gas charged on top of the gasLimit to cover destination chain costs.\n    uint16 destGasPerPayloadByte; //             \u2502 Destination chain gas charged each byte of `data` payload.\n    uint32 destDataAvailabilityOverheadGas; //   \u2502 Data availability gas charged for overhead costs e.g. for OCR.\n    uint16 destGasPerDataAvailabilityByte; //    \u2502 Gas units charged per byte of message data that needs availability.\n    uint16 destDataAvailabilityMultiplierBps; // \u2502 Multiplier for data availability gas, multiples of bps, or 0.0001.\n    // The following three properties are defaults, they can be overridden by setting the TokenTransferFeeConfig for a token.\n    uint16 defaultTokenFeeUSDCents; //           \u2502 Default token fee charged per token transfer.\n    uint32 defaultTokenDestGasOverhead; // \u2500\u2500\u2500\u2500\u2500\u2500\u256f Default gas charged to execute a token transfer on the destination chain.\n    uint32 defaultTxGasLimit; //\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e Default gas limit for a tx.\n    uint64 gasMultiplierWeiPerEth; //            \u2502 Multiplier for gas costs, 1e18 based so 11e17 = 10% extra cost.\n    uint32 networkFeeUSDCents; //                \u2502 Flat network fee to charge for messages, multiples of 0.01 USD.\n    uint32 gasPriceStalenessThreshold; //        \u2502 The amount of time a gas price can be stale before it is considered invalid (0 means disabled).\n    bool enforceOutOfOrder; //                   \u2502 Whether to enforce the allowOutOfOrderExecution extraArg value to be true.\n    bytes4 chainFamilySelector; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Selector that identifies the destination chain's family. Used to determine the correct validations to perform for the dest chain.\n  }\n\n  /// @dev Struct to hold the configs and its destination chain selector. Same as DestChainConfig but with the\n  /// destChainSelector so that an array of these can be passed in the constructor and applyDestChainConfigUpda", "n for token transfers.\n  struct TokenTransferFeeConfig {\n    uint32 minFeeUSDCents; // \u2500\u2500\u2500\u2500\u256e Minimum fee to charge per token transfer, multiples of 0.01 USD.\n    uint32 maxFe", "0.01 USD.\n    uint16 deciBps; //            \u2502 Basis points charged on token transfers, multiples of 0.1bps, or 1e-5.\n    uint32 destGasOverhead; //    \u2502 Gas charged to execute the token transfer on the destination chain.\n    //                            \u2502 Extra data availability bytes that are returned from the source pool and sent to\n    uint32 destBytesOverhead; //  \u2502 the destination pool. Must be >= Pool.CCIP_LOCK_OR_BURN_V1_RET_BYTES.\n    bool isEnabled; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether this token has custom transfer fees.\n  }\n\n  /// @dev Struct with token transfer fee configurations for a token, same as TokenTransferFeeConfig but with the token\n  /// address included.\n  struct TokenTransferFeeConfigSingleTokenArgs {\n    address token; // Token address.\n    TokenTransferFeeConfig tokenTran", " fee configurations for a destination chain and a set of tokens.\n  struct TokenTransferFeeConfigArgs {\n    uint64 destChainSelector; // Destination chain selector.\n    TokenTransferFeeConfigSingleTokenArgs[] ", " selector and token address so that an array of these can be passed in\n  /// the applyTokenTransferFeeConfigUpdates function to remove the token transfer fee configuration for a token.\n  struct TokenTransferFeeConfig", "address token; // // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e Token address.\n    uint64 premiumMultiplierWeiPerEth; // \u2500\u256f Multiplier for destination chain specific premiums.\n  }\n\n  /// @dev The base decimals for", "= 36;\n  /// @dev The decimals that Keystone reports prices in.\n  uint256 public constant KEYSTONE_PRICE_DECIMALS = 18;\n\n  string public constant override typeAndVersion = \"FeeQuoter 1.6.0-dev\";\n\n  /// @dev The gas price per unit of gas for a ", "struct AuthorizedCallerArgs {\n    address[] addedCallers;\n    address[] removedCallers;\n  }", "struct LocalRateLimitToken {\n    uint64 remoteChainSelector; // \u2500\u256e Remote chain selector for which to update the rate limit token mapping.\n    address localToken; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Token on the chain on which the multi-ARL is deployed.\n  }\n\n  /// @notice RateLimi", "s {\n    LocalRateLimitToken localTokenArgs; // Local token update args scoped to one remote chain.\n    bytes remoteToken; // Token on the remote chain, for OnRamp - dest, or OffRamp - source.\n  }\n\n  /// @notice Update a", "Args {\n    uint64 remoteChainSelector; // \u2500\u256e Remote chain selector to set config for.\n    bool isOutboundLane; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f If set to true, represents the outbound message lane (OnRamp), and the inbound message lane otherwise (OffRamp)\n    RateLimiter.Config rateLimiterConfig; // Rate limiter config to set\n  }\n\n  /// @notice Struct to store rate limit tok", "kenBucket inboundLaneBucket; // Bucket for the inbound lane (remote -> local).\n    RateLimiter.TokenBucket outboundLaneBucket; // Bucket for the outbound lane (local -> remote).\n  }\n\n  string public constant override typeAndVer", "struct AuthorizedCallerArgs {\n    address[] addedCallers;\n    address[] removedCallers;\n  }", "struct PreviousRamps {\n    address prevOnRamp; // Previous onRamp.\n    address prevOffRamp; // Previous offRamp.\n  }", "struct PreviousRampsArgs {\n    uint64 remoteChainSelector; // \u2500\u2500\u256e Chain selector.\n    bool overrideExistingRamps; // \u2500\u2500\u256f Whether to override existing ramps.\n    PreviousRamps prevRamps; // Previous on/off ramps.\n  }\n\n  string p", "struct OnRamp {\n    uint64 destChainSelector;\n    address onRamp;\n  }", "struct OffRamp {\n    uint64 sourceChainSelector;\n    address offRamp;\n  }", "plits.\n  struct OCR3Config {\n    Internal.OCRPluginType pluginType; // \u2500\u256e The plugin that the configuration is for.\n    uint64 chainSelector; //               \u2502 The (remote) chain that the configuration is for.\n    uint8 FRoleDON; //                     \u2502 The \"big F\" parameter for th", "r the OCR3 plugin. Protobuf encoded.\n  }\n\n  struct VersionedConfig {\n    uint32 version;\n    bytes32 configDigest;\n    OCR3Config config;\n  }\n\n  /// @notice Chain configuration.\n  /// Changes to chain configuration are detected out-of-band in plugins and decoded offchain.\n  struct ChainConfig {\n    bytes32[] readers; // The P2P IDs of the readers for the chain. These IDs must be registered in the capabilities registry.\n    uint8 fChain; // The fault tolerance parameter of the chain.\n    bytes config; // The chain configuration. This is kept intentionally opaque so as to add fields in the future if needed.\n  }\n\n  /// @notice Chain configuration information struct used in applyChainCon", "pdates and getAllChainConfigs.\n  struct ChainConfigArgs {\n    uint64 chainSelector;\n    ChainConf", " digests that is unique to the implementation.\n  uint256 private constant PREFIX = 0x000a << (256 - 16); // 0x000a00..00\n  bytes32 internal constant EMPTY_ENCODED_ADDRESS_HASH = keccak256(abi.encode(address(0)));\n  /// @dev 256 is the hard limit due to the bit encoding of their indexes into a uint256.\n  uint256 internal constant MAX_NUM_OR", "type(uint256).max << (256 - 16); // 0xFFFF00..00\n  /// @notice The max number of co", "struct TaggedRoot {\n    address commitStore;\n    bytes32 root;\n  }", "struct Signature {\n    bytes32 r;\n    bytes32 s;\n  }", "struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }", "struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }", "struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains.\n    bytes data; // Data payload.\n    EVMTokenAmount[] tokenAmounts; // Token transfers.\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2).\n  }", "struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }", "struct EVMExtraArgsV2 {\n    uint256 gasLimit;\n    bool allowOutOfOrderExecution;\n  }", "struct PriceUpdates {\n    TokenPriceUpdate[] tokenPriceUpdates;\n    GasPriceUpdate[] gasPriceUpdates;\n  }", "struct TokenPriceUpdate {\n    address sourceToken; // Source token.\n    uint224 usdPerToken; // 1e18 USD per 1e18 of the smallest token denomination.\n  }", "struct GasPriceUpdate {\n    uint64 destChainSelector; // Destination chain selector.\n    uint224 usdPerUnitGas; // 1e18 USD per smallest unit (e.g. wei) of destination chain gas.\n  }", "struct TimestampedPackedUint224 {\n    uint224 value; // \u2500\u2500\u2500\u2500\u2500\u2500\u256e Value in uint224, packed.\n    uint32 timestamp; // \u2500\u2500\u2500\u256f Timestamp of the most recent price update.\n  }\n\n  /// @dev Gas price", " {\n    // The source pool address, abi encoded. This value is trusted as it was obtained through the onRamp. It can be\n    // relied upon by the destination pool to validate the source pool.\n    bytes sourcePoolAddress;\n    // The address of the destination token, abi encoded in the case of EVM chains.\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\n    bytes destTokenAddress;\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes extraData;\n    uint32 destGasAmount; // The amount of gas available for the releaseOrMint and balanceOf calls on the offRamp\n  }\n\n  /// @notice Report", " {\n    uint64 sourceChainSelector; // Source chain selector for which the report is submitted.\n    Any2EVMRampMessage[] messages;\n    // Contains a bytes array for each message, each inner bytes array contains bytes per transferred token.\n    bytes[][] offchainTokenData;\n    bytes32[] proofs;\n    uint256 proofFlagBits;\n  }\n\n  /// @dev Any2EVMRa", "er {\n    bytes32 messageId; // Unique identifier for the message, generated with the source chain's encoding scheme (i.e. not necessarily abi.encoded).\n    uint64 sourceChainSelector; // \u2500\u2500\u256e the chain selector of the source chain, note: not chainId.\n    uint64 destChainSelector; //     \u2502 the chain selector of the destination chain, note: not chainId.\n    uint64 sequenceNumber; //        \u2502 sequence number, not unique across lanes.\n    uint64 nonce; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f nonce for this lane for this sender, not unique across senders/lanes.\n  }\n\n  struct EVM2AnyTokenTransfer {\n    // The source pool EVM addre", "This value is trusted as it was obtained through the onRamp. It can be relied\n    // upon by the destination pool to validate the source pool.\n    address sourcePoolAddress;\n    // The EVM address of the destination token.\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\n    bytes destTokenAddress;\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes extraData;\n    uint256 amount; // Amount of tokens.\n    // Destination chain data used to execute the token transfer on the destination chain. For an EVM destination, it\n    // consists of the amount of gas available for the releaseOrMint and transfer calls made by the offRamp.\n    bytes destExecData;\n  }\n\n  struct Any2EVMTokenTransfer {\n    // The source pool EVM addre", "ncoded to bytes. This value is trusted as it is obtained through the onRamp. It can\n    // be relied upon by the destination pool to validate the source pool.\n    bytes sourcePoolAddress;\n    address destTokenAddress; // \u2500\u256e Address of destination token\n    uint32 destGasAmount; //\u2500\u2500\u2500\u2500\u2500\u2500\u256f The amount of gas available for the releaseOrMint and transfer calls on the offRamp.\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes extraData;\n    uint256 amount; // Amount of tokens.\n  }\n\n  /// @notice Family-agnostic message routed to an OffRamp.\n  /// Note: hash(Any2E", "es sender; // sender address on the source chain.\n    bytes data; // arbitrary data payload supplied by the message sender.\n    address receiver; // receiver address on the destination chain.\n    uint256 gasLimit; // user supplied maximum gas amount available for dest chain execution.\n    Any2EVMTokenTransfer[] tokenAmounts; // array of tokens and amounts to transfer.\n  }\n\n  /// @notice Family-agnostic message emitted from the OnRamp.\n  /// Note: hash(An", "ress sender; // sender address on the source chain.\n    bytes data; // arbitrary data payload supplied by the message sender.\n    bytes receiver; // receiver address on the destination chain.\n    bytes extraArgs; // destination-chain specific extra args, such as the gasLimit for EVM chains.\n    address feeToken; // fee token.\n    uint256 feeTokenAmount; // fee token amount.\n    uint256 feeValueJuels; // fee amount in Juels.\n    EVM2AnyTokenTransfer[] tokenAmounts; // array of tokens and amounts to transfer.\n  }\n\n  // bytes4(keccak256(\"CCIP ChainFamilySelector EVM\"));\n  bytes4 public constant C", "that the Merkle Root is scoped to\n    bytes onRampAddress; //        Generic onramp address, to support arbitrary sources; for EVM, use abi.encode\n    uint64 minSeqNr; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e Minimum sequence number, inclusive\n    uint64 maxSeqNr; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Maximum sequence number, inclusive\n    bytes32 merkleRoot; //         Merkle root covering the interval & source chain messages\n  }\n}\n", "struct LockOrBurnInV1 {\n    bytes receiver; //  The recipient of the tokens on the destination chain, abi encoded.\n    uint64 remoteChainSelector; // \u2500\u256e The chain ID of the destination chain.\n    address originalSender; // \u2500\u2500\u2500\u2500\u2500\u256f The original sender of the tx on the source chain.\n    uint256 amount; //  The amount of tokens to lock or burn, denominated in the source token's decimals.\n    address localToken; //  The address on this chain of the token to lock or burn.\n  }\n\n  struct LockO", "nOutV1 {\n    // The address of the destination token, abi encoded in the case of EVM chains.\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\n    bytes destTokenAddress;\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes destPoolData;\n  }\n\n  struct Relea", "MintInV1 {\n    bytes originalSender; //          The original sender of the tx on the source chain.\n    uint64 remoteChainSelector; // \u2500\u256e The chain ID of the source chain.\n    address receiver; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The recipient of the tokens on the destination chain.\n    uint256 amount; //                The amount of tokens to release or mint, denominated in the source token's decimals.\n    address localToken; //            The address on this chain of the token to release or mint.\n    /// @dev WARNING: sourcePoolAddress should be checked prior to any processing of funds. Make sure it matches the\n    /// expected pool address for the given remoteChainSelector.\n    bytes sourcePoolAddress; //       The address of the source pool, abi encoded in the case of EVM chains.\n    bytes sourcePoolData; //          The data received from the source pool to process the release or mint.\n    /// @dev WARNING: offchainTokenData is untrusted data.\n    bytes offchainTokenData; //       The offchain data to process the release or mint.\n  }\n\n  struct ReleaseOrMintOutV1 {\n    // The n", "r of tokens released or minted on the destination chain, denominated in the local token's decimals.\n    // This value is expected to be equal to the ReleaseOrMintInV1.amount in the case where the source and destination\n    // chain have the same number of decimals.\n    uint256 destinationAmount;\n  }\n}\n", "struct TokenBucket {\n    uint128 tokens; // \u2500\u2500\u2500\u2500\u2500\u2500\u256e Current number of tokens that are in the bucket.\n    uint32 lastUpdated; //   \u2502 Timestamp in seconds of the last token refill, good for 100+ years.\n    bool isEnabled; // \u2500\u2500\u2500\u2500\u2500\u2500\u256f Indication whether the rate limiting is enabled or not.\n    uint128 capacity; // \u2500\u2500\u2500\u2500\u256e Maximum number of tokens that can be in the bucket.\n    uint128 rate; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Number of tokens per second that the bucket is refilled.\n  }\n\n  struct Config {\n    bool isEnabled; // Indication whet", "the rate limiting should be enabled.\n    uint128 capacity; // \u2500\u2500\u2500\u2500\u256e Specifies the capacity of the rate limiter.\n    uint128 rate; //  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Specifies the rate of the rate limiter.\n  }\n\n  /// @notice _consume removes the given tokens from the pool, lowering the rate t", "struct ConfigInfo {\n    bytes32 configDigest;\n    uint8 F; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e maximum number of faulty/dishonest oracles the system can tolerate.\n    uint8 n; //                              \u2502 number of configured signers.\n    bool isSignatureVerificationEnabled; // \u2500\u256f if true, requires signers and verifies signatures on transmission.\n  }\n\n  /// @notice Used for s_oracles[a].role, where a is an address,", "s/s_transmitters.\n    Role role; // \u2500\u2500\u2500\u256f Role of the address which mapped to this struct.\n  }\n\n  /// @notice OCR configuration for a single OCR plugin within a DON.\n  stru", "TE: len(signers) can be different from len(transmitters). There is no index relationship between the two arrays.\n    address[] signers; //      addresses oracles use to sign the reports.\n    address[] transmitters; // addresses oracles use to transmit the reports.\n  }\n\n  /// @notice Args to update an OCR Config.\n  struct OCRConfigArgs {\n    byt", " uint8 ocrPluginType; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e OCR plugin type to update config for.\n    uint8 F; //                              \u2502 Maximum number of faulty/dishonest oracles.\n    bool isSignatureVerificationEnabled; // \u2500\u256f If true, requires signers and verifies signatures on transmission.\n    address[] signers; // signing address of each oracle.\n    address[] transmitters; // the address the oracle sends transactions from.\n  }\n\n  /// @notice mapping of OCR plugin type -> DON config.\n  mapping(uint8 ocrPluginType => OCRConfig config) internal s_", "struct ConfigInfo {\n    bytes32 configDigest;\n    uint8 F; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e maximum number of faulty/dishonest oracles the system can tolerate.\n    uint8 n; //                              \u2502 number of configured signers.\n    bool isSignatureVerificationEnabled; // \u2500\u256f if true, requires signers and verifies signatures on transmission.\n  }\n\n  /// @notice Used for s_oracles[a].role, where a is an address,", "s/s_transmitters.\n    Role role; // \u2500\u2500\u2500\u256f Role of the address which mapped to this struct.\n  }\n\n  /// @notice OCR configuration for a single OCR plugin within a DON.\n  stru", "TE: len(signers) can be different from len(transmitters). There is no index relationship between the two arrays.\n    address[] signers; //      addresses oracles use to sign the reports.\n    address[] transmitters; // addresses oracles use to transmit the reports.\n  }\n\n  /// @notice Args to update an OCR Config.\n  struct OCRConfigArgs {\n    byt", " uint8 ocrPluginType; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e OCR plugin type to update config for.\n    uint8 F; //                              \u2502 Maximum number of faulty/dishonest oracles.\n    bool isSignatureVerificationEnabled; // \u2500\u256f If true, requires signers and verifies signatures on transmission.\n    address[] signers; // signing address of each oracle.\n    address[] transmitters; // the address the oracle sends transactions from.\n  }\n\n  /// @notice mapping of OCR plugin type -> DON config.\n  mapping(uint8 ocrPluginType => OCRConfig config) internal s_", "struct StaticConfig {\n    uint64 chainSelector; // \u2500\u2500\u2500\u2500\u256e Destination chainSelector\n    IRMNRemote rmnRemote; // \u2500\u2500\u2500\u2500\u256f RMN Verification Contract\n    address tokenAdminRegistry; // Token admin registry address\n    address nonceManager; // Nonce manager address\n  }\n\n  /// @dev Per-cha", "nfig {\n    IRouter router; // \u2500\u2500\u2500\u256e Local router to use for messages coming from this source chain.\n    bool isEnabled; //    \u2502 Flag whether the source chain is enabled or not.\n    uint64 minSeqNr; // \u2500\u2500\u256f The min sequence number expected for future messages.\n    bytes onRamp; // OnRamp address on the source chain.\n  }\n\n  /// @dev Same as SourceChainConf", "Router router; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e  Local router to use for messages coming from this source chain.\n    uint64 sourceChainSelector; // \u2502  Source chain selector of the config to update.\n    bool isEnabled; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  Flag whether the source chain is enabled or not.\n    bytes onRamp; // OnRamp address on the source chain.\n  }\n\n  /// @dev Dynamic offRamp config.\n  /// @dev Since DynamicConfig is part of DynamicConf", "address on the local chain.\n    uint32 permissionLessExecutionThresholdSeconds; // \u2502 Waiting time before manual execution is enabled.\n    bool isRMNVerificationDisabled; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Flag whether the RMN verification is disabled or not.\n    address messageInterceptor; // Optional, validates incoming messages (zero address = no interceptor).\n  }\n\n  /// @dev Report that is committed by the observing DON at the committing phase.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct Commit", "ource chain to commit.\n    IRMNRemote.Signature[] rmnSignatures; // RMN signatures on the merkle roots.\n  }\n\n  /// @dev Both receiverExecutionGasLimit and tokenGasOverrides are optional. To indicate no override, set the value\n  /// to 0. The length of tokenGasOverrides must match the length o", "Amount, length must be same as tokenAmounts.\n  }\n\n  // STATIC CONFIG\n  string public constant override typeAndVersion = \"OffRamp 1.6.0-dev\";\n  /// @dev Hash of encoded address(0) used for empty address checks.\n  bytes32 internal const", "struct StaticConfig {\n    uint64 chainSelector; // \u2500\u2500\u2500\u2500\u256e Source chain selector.\n    IRMNRemote rmnRemote; // \u2500\u2500\u2500\u2500\u256f RMN remote address.\n    address nonceManager; //       Nonce manager address.\n    address tokenAdminRegistry; // Token admin registry address.\n  }\n\n  /// @dev Struct ", " {\n    address feeQuoter; // FeeQuoter address.\n    bool reentrancyGuardEntered; // Reentrancy protection.\n    address messageInterceptor; // Optional message interceptor to validate messages. Zero address = no interceptor.\n    address feeAggregator; // Fee aggregator address.\n    address allowlistAdmin; // authorized admin to add or remove allowed senders.\n  }\n\n  /// @dev Struct ", "ig {\n    // The last used sequence number. This is zero in the case where no messages have yet been sent.\n    // 0 is not a valid sequence number for any real transaction as this value will be incremented before use.\n    uint64 sequenceNumber; // \u2500\u2500\u256e The last used sequence number.\n    bool allowlistEnabled; //   \u2502 True if the allowlist is enabled.\n    IRouter router; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Local router address  that is allowed to send messages to the destination chain.\n    EnumerableSet.AddressSet allowedSendersList; // The list of addresses allowed to send messages.\n  }\n\n  /// @dev Same as DestChainConfig but with th", "nSelector; // \u2500\u256e Destination chain selector.\n    IRouter router; //            \u2502 Source router address.\n    bool allowlistEnabled; // \u2500\u2500\u2500\u2500\u256f True if the allowlist is enabled.\n  }\n\n  /// @dev Struct to hold the allowlist configuration args per", "\u256e Destination chain selector.\n    bool allowlistEnabled; // \u2500\u2500\u2500\u2500\u2500\u256f True if the allowlist is enabled.\n    address[] addedAllowlistedSenders; // list of senders to be added to the allowedSendersList.\n    address[] removedAllowlistedSenders; // list of senders to be removed from the allowedSendersList.\n  }\n\n  // STATIC CONFIG\n  string public constant override typeAndVersion = \"OnRamp 1.", "struct ChainUpdate {\n    uint64 remoteChainSelector; // \u2500\u2500\u256e Remote chain selector\n    bool allowed; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the chain should be enabled\n    bytes remotePoolAddress; //        Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; //       Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n  }\n\n  struct RemoteChainConfig {\n    RateL", "er.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    bytes remotePoolAddress; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n  }\n\n  /// @dev The bridgeable token that i", "struct ChainUpdate {\n    uint64 remoteChainSelector; // \u2500\u2500\u256e Remote chain selector\n    bool allowed; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the chain should be enabled\n    bytes remotePoolAddress; //        Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; //       Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n  }\n\n  struct RemoteChainConfig {\n    RateL", "er.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    bytes remotePoolAddress; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n  }\n\n  /// @dev The bridgeable token that i", "struct ChainUpdate {\n    uint64 remoteChainSelector; // \u2500\u2500\u256e Remote chain selector\n    bool allowed; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the chain should be enabled\n    bytes remotePoolAddress; //        Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; //       Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n  }\n\n  struct RemoteChainConfig {\n    RateL", "er.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    bytes remotePoolAddress; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n  }\n\n  /// @dev The bridgeable token that i", "struct ChainUpdate {\n    uint64 remoteChainSelector; // \u2500\u2500\u256e Remote chain selector\n    bool allowed; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the chain should be enabled\n    bytes remotePoolAddress; //        Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; //       Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n  }\n\n  struct RemoteChainConfig {\n    RateL", "er.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    bytes remotePoolAddress; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n  }\n\n  /// @dev The bridgeable token that i", "struct ChainUpdate {\n    uint64 remoteChainSelector; // \u2500\u2500\u256e Remote chain selector\n    bool allowed; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the chain should be enabled\n    bytes remotePoolAddress; //        Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; //       Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n  }\n\n  struct RemoteChainConfig {\n    RateL", "er.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    bytes remotePoolAddress; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n  }\n\n  /// @dev The bridgeable token that i", "struct ChainUpdate {\n    uint64 remoteChainSelector; // \u2500\u2500\u256e Remote chain selector\n    bool allowed; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the chain should be enabled\n    bytes remotePoolAddress; //        Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; //       Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n  }\n\n  struct RemoteChainConfig {\n    RateL", "er.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    bytes remotePoolAddress; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n  }\n\n  /// @dev The bridgeable token that i", "struct ChainUpdate {\n    uint64 remoteChainSelector; // \u2500\u2500\u256e Remote chain selector\n    bool allowed; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the chain should be enabled\n    bytes remotePoolAddress; //        Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; //       Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n  }\n\n  struct RemoteChainConfig {\n    RateL", "er.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    bytes remotePoolAddress; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n  }\n\n  /// @dev The bridgeable token that i", "struct ChainUpdate {\n    uint64 remoteChainSelector; // \u2500\u2500\u256e Remote chain selector\n    bool allowed; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the chain should be enabled\n    bytes remotePoolAddress; //        Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; //       Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n  }\n\n  struct RemoteChainConfig {\n    RateL", "er.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    bytes remotePoolAddress; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n  }\n\n  /// @dev The bridgeable token that i", "struct MessageAndAttestation {\n    bytes message;\n    bytes attestation;\n  }", "struct DomainUpdate {\n    bytes32 allowedCaller; //       Address allowed to mint on the domain\n    uint32 domainIdentifier; // \u2500\u2500\u256e Unique domain ID\n    uint64 destChainSelector; //  \u2502 The destination chain for this domain\n    bool enabled; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the domain is enabled\n  }\n\n  struct SourceTokenDataPayload {\n", "uint64 nonce;\n    uint32 sourceDomain;\n  }\n\n  string public constant override ", "aller; //      Address allowed to mint on the domain\n    uint32 domainIdentifier; // \u2500\u256e Unique domain ID\n    bool enabled; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the domain is enabled\n  }\n\n  // A mapping of CCIP chain identifiers to destination domains\n", "struct ChainUpdate {\n    uint64 remoteChainSelector; // \u2500\u2500\u256e Remote chain selector\n    bool allowed; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the chain should be enabled\n    bytes remotePoolAddress; //        Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; //       Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n  }\n\n  struct RemoteChainConfig {\n    RateL", "er.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    bytes remotePoolAddress; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n  }\n\n  /// @dev The bridgeable token that i", "struct MessageAndAttestation {\n    bytes message;\n    bytes attestation;\n  }", "struct DomainUpdate {\n    bytes32 allowedCaller; //       Address allowed to mint on the domain\n    uint32 domainIdentifier; // \u2500\u2500\u256e Unique domain ID\n    uint64 destChainSelector; //  \u2502 The destination chain for this domain\n    bool enabled; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the domain is enabled\n  }\n\n  struct SourceTokenDataPayload {\n", "uint64 nonce;\n    uint32 sourceDomain;\n  }\n\n  string public constant override ", "aller; //      Address allowed to mint on the domain\n    uint32 domainIdentifier; // \u2500\u256e Unique domain ID\n    bool enabled; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the domain is enabled\n  }\n\n  // A mapping of CCIP chain identifiers to destination domains\n", "nsure that SourceChain.observerNodesBitmap in the home chain config &\n    // Signer.nodeIndex in the remote chain configs are appropriately updated when changing this field.\n    Node[] nodes;", " bytes offchainConfig; // Offchain configuration for RMN nodes.\n  }\n\n  struct DynamicConfig {\n    // No sorting requirement for source chains, it is most gas efficient to append new source chains to the right.\n    SourceChain[] sourceChains;\n    bytes offchainConfig; // Offchain configuration for RMN nodes.\n  }\n\n  /// @notice The main struct stored in the contract, containing the static and d", "ic parts of the config as well as\n  /// the version and the digest of the config.\n  struct VersionedConfig {\n    uint32 version;\n    bytes32 configDigest;\n    StaticConfig staticConfig;\n    DynamicConfig dynamicConfig;\n  }\n\n  string public constant override typeAndVersion = \"RMNHome 1.6.0-dev\";\n\n  /// @notice Used for encoding t", "onfig digest prefix, unique per Home contract implementation.\n  uint256 private constant PREFIX = 0x000b << (256 - 16); // 0x000b00..00.\n  /// @notice Used for encoding the config digest prefix\n  uint256 private constant PREFIX_MASK = type(u", "= 2;\n  /// @notice Helper to identify the zero config digest with less casting.\n  bytes32 private constant ZERO_DIGEST = bytes32(uint256(0", "struct Signature {\n    bytes32 r;\n    bytes32 s;\n  }", "struct Signer {\n    address onchainPublicKey; // \u2500\u256e For signing reports.\n    uint64 nodeIndex; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Maps to nodes in home chain config, should be strictly increasing.\n  }\n\n  /// @dev the contrac", "s32 rmnHomeContractConfigDigest; // Digest of the RMNHome contract config.\n    Signer[] signers; // List of signers.\n    uint64 f; // Max number of faulty RMN nodes; f+1 signers are required to verify a report, must configure 2f+1 signers in total.\n  }\n\n  /// @dev part of the", "256 destChainId; //                 To guard against chain selector misconfiguration.\n    uint64 destChainSelector; //  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The chain selector of the destination chain.\n    address rmnRemoteContractAddress; // \u2500\u256f The address of this contract.\n    address offrampAddress; //              The address of the offramp on the same chain as this contract.\n    bytes32 rmnHomeContractConfigDigest; // The digest of the RMNHome contract config.\n    Internal.MerkleRoot[] merkleRoots; //   The dest lane updates.\n  }\n\n  /// @dev this is included in the preimage ", "struct TokenConfig {\n    address administrator; // the current administrator of the token\n    address pendingAdministrator; // the address that is pending to become the new administrator\n    address tokenPool; // the token pool for this token. Can be address(0) if not deployed or not configured.\n  }", "struct RemoteTokenPoolInfo {\n    uint64 remoteChainSelector; // The CCIP specific selector for the remote chain\n    bytes remotePoolAddress; // The address of the remote pool to either deploy or use as is. If empty, address\n    // will be predicted\n    bytes remotePoolInitCode; // Remote pool creation code if it needs to be deployed, without constructor params\n    // appended to the end.\n    RemoteChainConfig remoteChainConfig; // The addresses of the remote RMNProxy, Router, and factory for determining\n    // the remote address\n    PoolType poolType; // The type of pool to deploy, either Burn/Mint or Lock/Release\n    bytes remoteTokenAddress; // EVM address for remote token. If empty, the address will be predicted\n    bytes remoteTokenInitCode; // The init code to be deployed on the remote chain and includes constructor params\n    RateLimiter.Config rateLimiterConfig; // Token Pool rate limit. Values will be applied on incoming an outgoing messages\n  }", "struct RemoteChainConfig {\n    address remotePoolFactory; // The factory contract on the remote chain which will make the deployment\n    address remoteRouter; // The router on the remote chain\n    address remoteRMNProxy; // The RMNProxy contract on the remote chain\n  }", "struct Permission {\n    address forwarder; // \u2500\u2500\u2500\u2500\u2500\u2500\u256e The address of the forwarder (20 bytes)\n    bytes10 workflowName; //    \u2502 The name of the workflow in bytes10\n    bytes2 reportName; // \u2500\u2500\u2500\u2500\u2500\u2500\u256f The name of the report in bytes2\n    address workflowOwner; // \u2500\u2500\u256e The address of the workflow owner (20 bytes)\n    bool isAllowed; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Whether the report is allowed or not (1 byte)\n  }\n\n  /// @notice Event emitted when report permissions ar", "struct NodeInfo {\n    /// @notice The id of the node operator that manages this node\n    uint32 nodeOperatorId;\n    /// @notice The number of times the node's configuration has been updated\n    uint32 configCount;\n    /// @notice The ID of the Workflow DON that the node belongs to. A node can\n    /// only belong to one DON that accepts Workflows.\n    uint32 workflowDONId;\n    /// @notice The signer address for application-layer message verification.\n    bytes32 signer;\n    /// @notice This is an Ed25519 public key that is used to identify a node.\n    /// This key is guaranteed to be unique in the CapabilitiesRegistry. It is\n    /// used to identify a node in the the P2P network.\n    bytes32 p2pId;\n    /// @notice Public key used to encrypt secrets for this node\n    bytes32 encryptionPublicKey;\n    /// @notice The list of hashed capability IDs supported by the node\n    bytes32[] hashedCapabilityIds;\n    /// @notice The list of capabilities DON Ids supported by the node. A node\n    /// can belong to multiple capabilities DONs. This list does not include a\n    /// Workflow DON id if the node belongs to one.\n    uint256[] capabilitiesDONIds;\n  }", "struct AuthorizedCallerArgs {\n    address[] addedCallers;\n    address[] removedCallers;\n  }", "struct AddressToAddressMap {\n    EnumerableMap.UintToAddressMap _inner;\n  }", "struct AddressToBytes32Map {\n    EnumerableMap.Bytes32ToBytes32Map _inner;\n  }", "struct AddressToBytesMap {\n    EnumerableMapBytes32.Bytes32ToBytesMap _inner;\n  }", "struct Bytes32ToBytesMap {\n    EnumerableSet.Bytes32Set _keys;\n    mapping(bytes32 => bytes) _values;\n  }", "struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position is the index of the value in the `values` array plus 1.\n    // Position 0 is used to mean a value is not in the set.\n    mapping(bytes32 value => uint256) _positions;\n  }", "struct Bytes32Set {\n    Set _inner;\n  }", "struct AddressSet {\n    Set _inner;\n  }", "struct UintSet {\n    Set _inner;\n  }", "struct Bytes16Set {\n    Set _inner;\n  }", "struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }", "struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }", "struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }", "struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }", "struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }", "struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }", "struct Bytes32Set {\n    Set _inner;\n  }", "struct AddressSet {\n    Set _inner;\n  }", "struct UintSet {\n    Set _inner;\n  }", "struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }", "struct Bytes32Set {\n        Set _inner;\n    }", "struct AddressSet {\n        Set _inner;\n    }", "struct UintSet {\n        Set _inner;\n    }"]